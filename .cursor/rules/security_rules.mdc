# Security Rules for secure-vibe Project

**Tech Stack:** Next.js 15.5, Clerk Authentication, Convex Database, TypeScript
**Security Level:** High - Payment features present via Clerk Billing
**Last Updated:** October 12, 2025
**Dependencies Status:** 0 known vulnerabilities

## Key Principle: Defense-in-Depth

Every API route handling sensitive operations MUST apply multiple security layers:
1. Rate limiting (prevent brute force)
2. CSRF protection (prevent cross-site attacks)
3. Input validation (prevent injection/XSS)
4. Authentication (verify identity via Clerk)
5. Error handling (prevent information leakage)

---

## 1. API Route Security - MANDATORY PATTERNS

### Rule: Always Apply Security Middlewares

For ANY new API route that modifies data (POST, PUT, DELETE) or handles user input:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { withRateLimit } from '@/lib/withRateLimit';
import { withCsrf } from '@/lib/withCsrf';
import { validateRequest } from '@/lib/validateRequest';
import { handleApiError } from '@/lib/errorHandler';
import { auth } from '@clerk/nextjs/server';

async function handler(request: NextRequest) {
  try {
    // 1. Authentication via Clerk
    const { userId } = await auth();
    if (!userId) {
      return handleUnauthorizedError();
    }

    // 2. Validate input
    const body = await request.json();
    const validation = validateRequest(yourSchema, body);

    if (!validation.success) {
      return validation.response;
    }

    // 3. Use validated data (already sanitized)
    const data = validation.data;

    // 4. Business logic
    // ...

    return NextResponse.json({ success: true });
  } catch (error) {
    return handleApiError(error, 'route-name');
  }
}

// Apply security layers (order matters!)
export const POST = withRateLimit(withCsrf(handler));

export const config = {
  runtime: 'nodejs',
};
```

### When to Apply Each Middleware

**`withRateLimit()`** - Apply to:
- ‚úÖ Any route that could be abused (spam, brute force)
- ‚úÖ Login-like operations (even if Clerk handles auth)
- ‚úÖ Data creation/modification endpoints
- ‚úÖ Contact/support form endpoints
- ‚úÖ Webhooks (to prevent DoS)

**`withCsrf()`** - Apply to:
- ‚úÖ All POST/PUT/DELETE operations
- ‚úÖ Any state-changing operation
- ‚úÖ Form submissions
- ‚ùå Skip for: GET requests, public read-only endpoints

**Combining Both:**
```typescript
// For maximum protection
export const POST = withRateLimit(withCsrf(handler));

// Order matters: rate limit first, then CSRF
```

---

## 2. Input Validation - MANDATORY

### Rule: Never Trust User Input - Always Validate with Zod

**Import schemas from `lib/validation.ts`:**

```typescript
import {
  emailSchema,
  safeTextSchema,
  safeLongTextSchema,
  usernameSchema,
  urlSchema,
  contactFormSchema,
  createPostSchema,
  updateProfileSchema
} from '@/lib/validation';
import { validateRequest } from '@/lib/validateRequest';
```

**Usage Pattern:**

```typescript
async function handler(request: NextRequest) {
  const body = await request.json();

  // Validate and sanitize
  const validation = validateRequest(createPostSchema, body);

  if (!validation.success) {
    return validation.response; // Returns 400 with field errors
  }

  // TypeScript knows exact shape, data is XSS-sanitized
  const { title, content, tags } = validation.data;

  // Use sanitized data safely
}
```

### XSS Sanitization

**All validation schemas automatically remove:**
- `<` - Prevents opening tags
- `>` - Prevents closing tags
- `"` - Prevents attribute injection
- `&` - Prevents HTML entity injection

**Preserved:**
- `'` - Apostrophes (for names like O'Neal, D'Angelo)

### Custom Schemas

**When creating custom schemas:**

```typescript
// lib/validation.ts (add your schema here)
export const myCustomSchema = z.object({
  field: z.string()
    .min(1, 'Required')
    .max(200, 'Too long')
    .trim()
    .transform((val) => val.replace(/[<>"&]/g, '')),  // XSS sanitization
});
```

### Common Validation Patterns

```typescript
// Email
const validation = validateRequest(emailSchema, email);

// Short text (names, titles)
const validation = validateRequest(safeTextSchema, name);

// Long text (bios, comments)
const validation = validateRequest(safeLongTextSchema, bio);

// URL (HTTPS only)
const validation = validateRequest(urlSchema, website);

// Complete forms
const validation = validateRequest(contactFormSchema, formData);
```

**Never:**
- ‚ùå Use `body.field` directly without validation
- ‚ùå Manually sanitize with `.replace()` - use Zod schemas
- ‚ùå Skip validation for "trusted" input
- ‚ùå Validate client-side only

---

## 3. Authentication & Authorization

### Rule: Use Clerk's `auth()` for Authentication

```typescript
import { auth } from '@clerk/nextjs/server';

async function handler(request: NextRequest) {
  const { userId } = await auth();

  if (!userId) {
    return handleUnauthorizedError('Authentication required');
  }

  // User is authenticated, userId available
  // Use userId to associate data with user in Convex
}
```

**Never:**
- ‚ùå Implement custom JWT/session logic
- ‚ùå Store passwords or credentials
- ‚ùå Create custom login/logout endpoints (Clerk handles this)
- ‚ùå Manually parse Clerk tokens

### Rule: Check Authorization for Resource Access (When Applicable)

**If your API accesses user-specific resources:**

```typescript
async function handler(request: NextRequest) {
  const { userId } = await auth();
  if (!userId) return handleUnauthorizedError();

  // Get resource from database
  const resource = await getResource(resourceId);

  // Check ownership
  if (resource.userId !== userId) {
    return handleForbiddenError('You do not have access to this resource');
  }

  // Proceed with authorized operation
}
```

**Never:**
- ‚ùå Assume authentication equals authorization
- ‚ùå Skip ownership checks for user data
- ‚ùå Allow users to access other users' private data

---

## 4. Error Handling - Prevent Information Leakage

### Rule: Use Error Handlers from `lib/errorHandler.ts`

**Import all error handlers:**

```typescript
import {
  handleApiError,
  handleValidationError,
  handleForbiddenError,
  handleUnauthorizedError,
  handleNotFoundError
} from '@/lib/errorHandler';
```

**Usage:**

```typescript
// Unexpected errors (500)
try {
  // risky operation
} catch (error) {
  return handleApiError(error, 'route-name');
}

// Validation errors (400)
return handleValidationError('Invalid input', { email: 'Required' });

// Authorization errors (403)
return handleForbiddenError('Access denied');

// Authentication errors (401)
return handleUnauthorizedError('Please sign in');

// Not found errors (404)
return handleNotFoundError('Post');
```

**This ensures:**
- ‚úÖ Production: Generic messages (no stack traces, paths, or internal details)
- ‚úÖ Development: Full error details for debugging
- ‚úÖ Consistent error response format
- ‚úÖ Proper HTTP status codes

**Never:**
- ‚ùå `return NextResponse.json({ error: error.message }, { status: 500 })`
- ‚ùå Include `error.stack` in responses
- ‚ùå Expose database errors to clients
- ‚ùå Return different error messages that reveal system internals

---

## 5. Secure Cookies

### Rule: Use Secure Cookie Configuration

**For any custom cookies, use these settings:**

```typescript
response.cookies.set('cookie-name', value, {
  httpOnly: true,                                    // Prevent XSS access
  sameSite: 'strict',                                // CSRF protection
  secure: process.env.NODE_ENV === 'production',    // HTTPS only in prod
  maxAge: 3600,                                      // Expiration
  path: '/',                                         // Cookie scope
});
```

**Never:**
- ‚ùå Set cookies without `httpOnly: true`
- ‚ùå Use `sameSite: 'none'` or `sameSite: 'lax'`
- ‚ùå Skip `secure` flag in production
- ‚ùå Create long-lived cookies without expiration

---

## 6. Convex Database Operations

### Rule: Validate Input in Convex Mutations

**In Convex mutation files:**

```typescript
// convex/posts.ts
import { mutation } from "./_generated/server";
import { createPostSchema } from "../lib/validation";

export const createPost = mutation({
  handler: async (ctx, args) {
    // Validate input with Zod
    const validation = createPostSchema.safeParse(args);

    if (!validation.success) {
      throw new Error("Invalid input: " + validation.error.message);
    }

    // Use sanitized data
    const { title, content } = validation.data;

    await ctx.db.insert("posts", {
      title,
      content,
      userId: ctx.auth.userId,
      createdAt: Date.now()
    });
  }
});
```

**Never:**
- ‚ùå Insert `args` directly into database
- ‚ùå Skip validation in Convex mutations
- ‚ùå Trust data from frontend without sanitization

---

## 7. CSRF Protection

### Rule: Protect State-Changing Operations

**Fetch CSRF token before POST requests:**

```typescript
// Client-side
const response = await fetch('/api/csrf', { credentials: 'include' });
const { csrfToken } = await response.json();

// Use in POST request
await fetch('/api/your-endpoint', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'X-CSRF-Token': csrfToken
  },
  credentials: 'include',
  body: JSON.stringify(data)
});
```

**Server-side - wrap handler:**

```typescript
export const POST = withCsrf(handler);
```

**CSRF tokens are:**
- ‚úÖ Single-use (cleared after validation)
- ‚úÖ Session-bound (HMAC with session ID)
- ‚úÖ HTTP-only cookies (XSS protection)
- ‚úÖ SameSite=Strict (CSRF protection)

**Never:**
- ‚ùå Skip CSRF for POST/PUT/DELETE operations
- ‚ùå Send CSRF tokens in URL parameters
- ‚ùå Reuse tokens across requests

---

## 8. Rate Limiting

### Rule: Prevent Abuse with Rate Limiting

**Apply to endpoints that could be abused:**

```typescript
import { withRateLimit } from '@/lib/withRateLimit';

export const POST = withRateLimit(handler);
```

**Current Configuration:**
- 5 requests per minute per IP address
- Tracks by `x-forwarded-for` or `x-real-ip` header
- Returns HTTP 429 when exceeded

**Applies to:**
- ‚úÖ Contact/support forms
- ‚úÖ Data creation endpoints
- ‚úÖ Password reset (if custom)
- ‚úÖ Webhook endpoints
- ‚úÖ Resource-intensive operations

**Note:** All routes using `withRateLimit()` share the same 5 req/min budget per IP.

**Never:**
- ‚ùå Create public endpoints without rate limiting
- ‚ùå Allow unlimited requests to expensive operations

---

## 9. Environment Variables & Secrets

### Rule: Use Environment Variables for All Secrets

**Required Variables:**

```bash
# CSRF Protection (generate with node -p "require('crypto').randomBytes(32).toString('base64url')")
CSRF_SECRET=<32-byte-base64url-string>
SESSION_SECRET=<32-byte-base64url-string>

# Clerk (from Clerk dashboard)
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_...
CLERK_SECRET_KEY=sk_...
NEXT_PUBLIC_CLERK_FRONTEND_API_URL=https://...

# Convex (from Convex dashboard)
CONVEX_DEPLOYMENT=...
NEXT_PUBLIC_CONVEX_URL=https://...
```

**Access in code:**

```typescript
// ‚úÖ Correct
const secret = process.env.CSRF_SECRET;

// ‚ùå Never do this
const secret = 'my-hardcoded-secret-123';
```

**Never:**
- ‚ùå Hardcode API keys, tokens, or secrets
- ‚ùå Commit `.env.local` to version control
- ‚ùå Log environment variables
- ‚ùå Expose secrets in client-side code
- ‚ùå Use `.env.local` values in `NEXT_PUBLIC_*` variables (they're exposed!)

---

## 10. Security Headers (Automatic)

### Headers Applied Automatically via middleware.ts

All responses include:
- `X-Content-Type-Options: nosniff`
- `X-Frame-Options: DENY`
- `Content-Security-Policy` (dynamic based on env vars)
- `X-Robots-Tag: noindex, nofollow` (protected routes)
- `Strict-Transport-Security` (production only)

**No action needed** - these are applied automatically.

**If modifying `middleware.ts`:**
- ‚úÖ Keep all existing security headers
- ‚úÖ Never hardcode domains in CSP
- ‚úÖ Always use environment variables for dynamic domains
- ‚úÖ Keep HSTS production-only (breaks localhost in dev)

---

## 11. Dependency Security

### Rule: Keep Dependencies Updated and Audited

**Before committing:**
```bash
# Check for vulnerabilities
npm audit --production

# Or use the automated script
bash scripts/security-check.sh
```

**Fix vulnerabilities:**
```bash
# Auto-fix minor/patch versions
npm audit fix

# Force major version updates (test thoroughly!)
npm audit fix --force
```

**Regular maintenance:**
- Run `npm audit` before every deploy
- Update dependencies monthly
- Monitor GitHub Dependabot alerts
- Keep Next.js updated for security patches

**Never:**
- ‚ùå Ignore npm audit warnings
- ‚ùå Use deprecated packages
- ‚ùå Skip testing after dependency updates

---

## 12. Logging & Debugging

### Rule: Never Log Sensitive Data

**Safe logging:**

```typescript
// ‚úÖ Safe - no sensitive data
console.log('User updated profile', { userId, timestamp: Date.now() });

// ‚ùå Unsafe - logs password
console.log('Login attempt', { email, password }); // NEVER DO THIS

// ‚ùå Unsafe - logs full request
console.log('Request body:', await request.json());
```

**Redact sensitive fields:**

```typescript
const SENSITIVE_FIELDS = ['password', 'token', 'secret', 'apiKey', 'ssn', 'creditCard'];

function safelog(data: any) {
  const sanitized = { ...data };
  SENSITIVE_FIELDS.forEach(field => {
    if (field in sanitized) {
      sanitized[field] = '[REDACTED]';
    }
  });
  console.log(sanitized);
}
```

**Never:**
- ‚ùå Log passwords, tokens, or API keys
- ‚ùå Log full request/response bodies
- ‚ùå Log environment variables
- ‚ùå Include PII in logs without redaction

---

## 13. Convex-Specific Security

### Rule: Validate All Mutation Arguments

**In Convex mutations:**

```typescript
// convex/items.ts
import { mutation } from "./_generated/server";
import { safeTextSchema, safeLongTextSchema } from "../lib/validation";

export const createItem = mutation({
  handler: async (ctx, args) {
    // Validate args with Zod
    const titleValidation = safeTextSchema.safeParse(args.title);
    const descValidation = safeLongTextSchema.safeParse(args.description);

    if (!titleValidation.success || !descValidation.success) {
      throw new Error("Invalid input");
    }

    // Use sanitized data
    await ctx.db.insert("items", {
      title: titleValidation.data,
      description: descValidation.data,
      userId: ctx.auth.userId,  // From Clerk authentication
      createdAt: Date.now()
    });
  }
});
```

**Never:**
- ‚ùå Insert `args` directly: `ctx.db.insert("items", args)`
- ‚ùå Skip validation in Convex
- ‚ùå Trust frontend validation alone

---

## 14. Testing Security Features

### Testing Commands

**1. CSRF Protection:**
```bash
curl http://localhost:3001/api/csrf
# Should return: {"csrfToken":"..."}
```

**2. Rate Limiting:**
```bash
node scripts/test-rate-limit.js
# Should show: 5 success, 5 rate limited
```

**3. Input Validation:**
```bash
curl -X POST http://localhost:3001/api/example-protected \
  -H "Content-Type: application/json" \
  -d '{"title": "Test<script>alert(1)</script>", "content": "Safe content"}'
# Should sanitize: removes <script> tags
```

**4. Security Headers:**
```bash
curl -I http://localhost:3001
# Should include: X-Frame-Options, CSP, X-Content-Type-Options
```

**5. Dependency Audit:**
```bash
bash scripts/security-check.sh
```

---

## 15. QUICK REFERENCE - Security Checklist

When creating a new API route, verify:

- [ ] Applied `withRateLimit()` if route could be abused
- [ ] Applied `withCsrf()` for POST/PUT/DELETE
- [ ] Validated input with Zod schemas from `lib/validation.ts`
- [ ] Used `handleApiError()` in catch block
- [ ] Checked authentication with `await auth()` from Clerk
- [ ] Checked authorization if accessing user-specific resources
- [ ] Used proper HTTP status codes (200, 400, 401, 403, 404, 429, 500)
- [ ] No sensitive data logged (passwords, tokens, PII)
- [ ] Set `runtime: 'nodejs'` in config for crypto operations
- [ ] Tested the endpoint before committing

---

## 16. Common Patterns - Copy & Paste Templates

### Template 1: Simple Protected Endpoint (No CSRF)

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { withRateLimit } from '@/lib/withRateLimit';
import { handleApiError } from '@/lib/errorHandler';
import { auth } from '@clerk/nextjs/server';

async function handler(request: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) return handleUnauthorizedError();

    // Your logic here

    return NextResponse.json({ success: true });
  } catch (error) {
    return handleApiError(error, 'route-name');
  }
}

export const GET = withRateLimit(handler);
export const config = { runtime: 'nodejs' };
```

### Template 2: Form Submission with Full Protection

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { withRateLimit } from '@/lib/withRateLimit';
import { withCsrf } from '@/lib/withCsrf';
import { validateRequest } from '@/lib/validateRequest';
import { handleApiError, handleUnauthorizedError } from '@/lib/errorHandler';
import { contactFormSchema } from '@/lib/validation';
import { auth } from '@clerk/nextjs/server';

async function handler(request: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) return handleUnauthorizedError();

    const body = await request.json();
    const validation = validateRequest(contactFormSchema, body);

    if (!validation.success) {
      return validation.response;
    }

    const { name, email, subject, message } = validation.data;

    // Process form (send email, save to DB, etc.)

    return NextResponse.json({ success: true });
  } catch (error) {
    return handleApiError(error, 'contact-form');
  }
}

export const POST = withRateLimit(withCsrf(handler));
export const config = { runtime: 'nodejs' };
```

### Template 3: Public Endpoint (No Auth, Yes Rate Limit)

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { withRateLimit } from '@/lib/withRateLimit';
import { validateRequest } from '@/lib/validateRequest';
import { handleApiError } from '@/lib/errorHandler';
import { emailSchema } from '@/lib/validation';

async function handler(request: NextRequest) {
  try {
    const body = await request.json();
    const validation = validateRequest(emailSchema, body);

    if (!validation.success) {
      return validation.response;
    }

    const email = validation.data;

    // Process (e.g., newsletter signup)

    return NextResponse.json({ success: true });
  } catch (error) {
    return handleApiError(error, 'newsletter');
  }
}

export const POST = withRateLimit(handler);
export const config = { runtime: 'nodejs' };
```

---

## 17. What NOT to Do - Common Anti-Patterns

### ‚ùå Anti-Pattern 1: No Security Middlewares

```typescript
// BAD - No protection
export async function POST(request: NextRequest) {
  const body = await request.json();
  // directly use body.field
  return NextResponse.json({ success: true });
}
```

### ‚ùå Anti-Pattern 2: Skipping Input Validation

```typescript
// BAD - No validation
async function handler(request: NextRequest) {
  const body = await request.json();
  const { title } = body; // Could contain <script> tags!
  await saveToDatabase(title);
}
```

### ‚ùå Anti-Pattern 3: Exposing Error Details in Production

```typescript
// BAD - Information leakage
catch (error) {
  return NextResponse.json({
    error: error.message,      // Could reveal internal paths
    stack: error.stack,        // Exposes code structure
    query: failedQuery         // Reveals database schema
  }, { status: 500 });
}
```

### ‚ùå Anti-Pattern 4: Hardcoding Secrets

```typescript
// BAD - Hardcoded secret
const apiKey = 'sk_live_123456789';

// GOOD - Environment variable
const apiKey = process.env.API_KEY;
```

### ‚ùå Anti-Pattern 5: No Rate Limiting on Public Forms

```typescript
// BAD - Can be spammed infinitely
export async function POST(request: NextRequest) {
  await sendEmail(data);
  return NextResponse.json({ success: true });
}

// GOOD - Rate limited
export const POST = withRateLimit(async (request: NextRequest) => {
  await sendEmail(data);
  return NextResponse.json({ success: true });
});
```

---

## 18. Pre-Deployment Security Checklist

Before deploying to production:

- [ ] All environment variables set in production environment
- [ ] `CSRF_SECRET` and `SESSION_SECRET` generated and configured
- [ ] Run `npm audit` - 0 vulnerabilities
- [ ] Test authentication flow with Clerk
- [ ] Verify CSRF tokens working
- [ ] Test rate limiting: `node scripts/test-rate-limit.js`
- [ ] Check security headers with `curl -I https://your-domain.com`
- [ ] Verify HSTS header present in production
- [ ] No secrets in code (grep for common patterns)
- [ ] Error messages generic (no stack traces exposed)
- [ ] All API routes have proper security middlewares
- [ ] Convex mutations validate input
- [ ] `.env.local` NOT committed to git

---

## 19. Security Monitoring

### What to Monitor Post-Deployment

**Server logs:**
- Repeated 429 (rate limit) errors - potential abuse
- 403 (CSRF) errors - potential attack
- 401/403 spikes - potential unauthorized access attempts
- Unusual error patterns

**Metrics to track:**
- Failed authentication attempts
- Rate limit violations per IP
- CSRF validation failures
- Input validation failures
- Error rates by endpoint

---

## 20. Resources & Documentation

**Project Security Docs:**
- `docs/security/SECURITY_IMPLEMENTATION.md` - Complete implementation guide
- `.claude/skills/security/security-awareness/` - AI code vulnerability analysis and examples
- `README.md` - Security Configuration section

**Testing Scripts:**
- `scripts/test-rate-limit.js` - Rate limiting verification
- `scripts/security-check.sh` - Dependency audit

**Example Routes:**
- `app/api/example-protected/route.ts` - Complete security stack example
- `app/api/test-rate-limit/route.ts` - Rate limiting test endpoint

**External Resources:**
- OWASP Top 10: https://owasp.org/www-project-top-ten/
- Next.js Security: https://nextjs.org/docs/app/guides/security
- Clerk Security: https://clerk.com/docs/security
- Convex Security: https://docs.convex.dev/production/hosting/authentication

---

## Summary: Security is Non-Negotiable

Every line of code that handles user input or performs sensitive operations MUST follow these security rules. There are no exceptions.

**Remember:**
- üîí Security is implemented, not assumed
- üîí Defense-in-depth: multiple layers of protection
- üîí Validate all input, sanitize all output
- üîí Fail secure: when in doubt, deny access
- üîí Test security features regularly

**For questions or security concerns, refer to:**
- `docs/security/SECURITY_IMPLEMENTATION.md`
- Sample secure implementation: `app/api/example-protected/route.ts`
